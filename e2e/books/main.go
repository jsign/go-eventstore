package main

import (
	ds "github.com/ipfs/go-datastore"
	es "github.com/textileio/go-eventstore"
	"github.com/textileio/go-eventstore/store"
)

type Book struct {
	ID       es.EntityID
	Title    string
	Author   string
	Comments []Comment
}

type Comment struct {
	Author string
	Body   string
	Rating int
}

func main() {
	s := createMemStore()

	model, err := s.RegisterJSONPatcher("Book", &Book{})
	checkErr(err)

	// Bootstrap the model with some books: two from Author1 and one from Author2
	{
		// Create a book with two comments
		book1 := &Book{ // Notice ID will be autogenerated
			Title:  "Title1",
			Author: "Author1",
			Comments: []Comment{
				Comment{
					Author: "AuthorComment1",
					Body:   "This book is great!",
					Rating: 4,
				},
				Comment{
					Author: "AuthorComment2",
					Body:   "Highly recommend this book!",
					Rating: 5,
				},
			},
		}

		// Create the book in the model
		err = model.Create(book1)
		checkErr(err)

		// Add some extra comment and save
		book1.Comments = append(book1.Comments, Comment{Author: "AuthorComment3", Body: "This book is terrible", Rating: 1})
		model.Save(book1)

		// Create other books without comments
		book2 := &Book{
			Title:  "Title2",
			Author: "Author2",
		}
		checkErr(model.Create(book2))

		// Create other book from Author1
		book3 := &Book{
			Title:  "Title3",
			Author: "Author1",
		}
		checkErr(model.Create(book3))

	}

	// Query all the books
	{
		var books []*Book
		err := model.Find(&books, &store.Query{})
		checkErr(err)
		if len(books) != 3 {
			panic("there should be three books")
		}
	}

	// Query the books from Author2
	{
		var books []*Book
		err := model.Find(&books, store.Where("Author").Eq("Author1"))
		checkErr(err)
		if len(books) != 2 {
			panic("Author1 should have two books")
		}
	}

	// Query book by two conditions
	{
		var books []*Book
		err := model.Find(&books, store.Where("Author").Eq("Author1").And("Title").Eq("Title3"))
		checkErr(err)
		if len(books) != 1 {
			panic("Author1 should have only one book with Title3")
		}
	}

	// Query book by OR condition
	{
		var books []*Book
		err := model.Find(&books, store.Where("Author").Eq("Author1").Or(store.Where("Author").Eq("Author2")))
		checkErr(err)
		if len(books) != 3 {
			panic("Author1 & Author2 have should have 3 books in total")
		}
	}

	// Query, Update, and Save
	{
		var books []*Book
		err := model.Find(&books, store.Where("Title").Eq("Title3"))
		checkErr(err)

		// Modify title
		book := books[0]
		book.Title = "ModifiedTitle"
		model.Save(book)
		err = model.Find(&books, store.Where("Title").Eq("Title3"))
		checkErr(err)
		if len(books) != 0 {
			panic("Book with Title3 shouldn't exist")
		}

		// Delete it
		err = model.Find(&books, store.Where("Title").Eq("ModifiedTitle"))
		checkErr(err)
		if len(books) != 1 {
			panic("Book with ModifiedTitle should exist")
		}
		model.Delete(books[0].ID)
		err = model.Find(&books, store.Where("Title").Eq("ModifiedTitle"))
		checkErr(err)
		if len(books) != 0 {
			panic("Book with ModifiedTitle shouldn't exist")
		}
	}

	// ToDo: Create indexes
	// ToDo: Use indexes for queries
	// ToDo: Sorting?
	// ToDo: Self-referencing conditionals
}

func createMemStore() *store.Store {
	datastore := ds.NewMapDatastore()
	dispatcher := es.NewDispatcher(es.NewTxMapDatastore())
	return store.NewStore(datastore, dispatcher)
}

func checkErr(err error) {
	if err != nil {
		panic(err)
	}
}
